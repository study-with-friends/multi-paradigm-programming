# 3장. 코드 : 객체 : 함수 = Generator : Iterator : LISP = IP : OOP : FP

> 스터디 중 나누었던 이야기들을 주제별로 요약하였습니다.

## 📌 1. 리스트 프로세싱과 함수형 스타일

### ✅ 개념 소개

코드를 리스트처럼 바라보고, 각 연산을 리스트의 요소로 처리하는 방식이다. map, filter, reduce 등의 메서드를 통해 복잡한 로직을 연속된 데이터 흐름으로 추상화할 수 있다. 이 접근법은 코드를 함수 단위로 나누고 관심사를 분리하는 데 유용하다.

### ✅ 효과

리스트 프로세싱은 각 연산의 목적이 명확하게 분리되므로 가독성이 높아지고, 테스트 및 재사용이 쉬워진다. 유지보수 측면에서도 각 연산을 독립적으로 다룰 수 있어 유리하다.

### ❗️비판 및 한계

모든 경우에 함수형 스타일이 가독성을 보장하지는 않는다. 체이닝이 과도하게 길어질 경우 오히려 이해하기 어려운 코드가 될 수 있으며, 실제로는 단순히 보기 좋은 예시만을 보여주는 경우도 많다. 예를 들어 redux-saga처럼 관심사를 지나치게 나누면 러닝 커브와 디버깅 비용이 높아질 수 있다.

## 📌 2. 함수형 프로그래밍의 현실 적용 한계

### ✅ 장점

순수 함수 기반의 함수형 프로그래밍은 테스트가 용이하고, 파이프라이닝이나 조합(composition)을 통해 재사용성이 높아진다. 데이터 흐름을 선언적으로 표현할 수 있다는 점도 장점이다.

### ❗️실무 한계

현실의 많은 로직은 외부 상태나 컨텍스트에 의존한다. 예를 들어 은행 시스템이나 실시간 처리 시스템처럼 맥락에 따라 분기되거나 상태를 추적해야 하는 경우, 순수 함수만으로 구현하는 것은 어렵거나 오히려 불편하다. 이러한 경우에는 명령형 접근이 더 직관적이고 효율적일 수 있다.

## 📌 3. 에러 처리 방식: try-catch vs 명시적 분기

### ✅ 분기 처리 방식

response.ok와 같이 응답의 성공 여부를 직접 판단하고, 조건에 따라 분기를 나누는 방식이다. 제어 흐름이 명확하고 가시성이 좋다는 장점이 있지만, 조건 분기가 많아질수록 코드가 장황해진다.

### ✅ try-catch + 에러 바운더리

비즈니스 로직과 에러 처리를 분리하여 관심사를 명확히 나눌 수 있다. 예를 들어 React의 ErrorBoundary나 Suspense와 같은 컴포넌트는 실패 시의 로직을 별도로 정의하게 함으로써 주 로직을 단순하게 유지할 수 있게 한다. 그러나 캐치를 누락할 경우 런타임 에러가 발생할 수 있다는 단점도 존재한다.

### 🧠 실무 예시

복잡한 시나리오(ex. 마이크 권한 검사, 상태 기반 이동 등)는 분기 처리가 더 유리하다. 반면 단순한 API 요청 실패 등은 바운더리로 처리하는 것이 더 깔끔한 패턴이 될 수 있다. 따라서 상황에 따라 병행적 접근이 필요하다.

## 📌 4. 지연 평가 (Lazy Evaluation)

### ✅ 개념

리스트 메서드 중 map, filter 등은 실제 데이터를 즉시 처리하지 않고, 평가를 지연시킨다. 이들은 내부적으로 연산을 정의해두고, find, reduce, take 등의 메서드가 호출될 때 실제로 평가된다.

### ✅ 중요 포인트

- forEach나 reduce는 즉시 평가를 수행하므로 지연 평가와는 구분된다.
- take 혹은 구조분해할당과 같은 평가 로직을 지연된 연산 체인의 끝에 두면, 그 시점에서 필요한 만큼만 연산을 지연하여 수행하게 된다.

### ✅ 실용적 강점

중간 결과를 메모리에 저장하지 않으므로 메모리 효율성이 높다. 예를 들어 concat을 지연 평가 기반으로 구현하면 두 리스트를 실제로 이어붙이지 않고, 연결된 상태만 유지하다가 take 시점에서 필요한 만큼만 평가할 수 있다. 이는 특히 대용량 데이터 처리에서 유용하다.

## 📌 5. 구조 분해 할당과 평가 시점

### ✅ 요점

구조 분해 할당은 실제로 해당 값을 사용할 때에만 평가가 수행된다. 즉, 값을 구조 분해하더라도 사용하지 않으면 메모리에 로드되거나 평가되지 않는다. 이 역시 지연 평가의 일종으로 간주할 수 있으며, 선언적인 스타일에 적합하다.

## 📌 6. 리스프(LISP)와 매크로

### ✅ 리스프의 특징

리스프는 코드를 데이터처럼 다룰 수 있는 언어로, 사용자 정의 매크로를 통해 언어의 문법을 확장할 수 있다. S-Expression 구조를 기반으로 파이프 오퍼레이터처럼 새로운 구문적 기능을 직접 정의할 수 있다.

### ✅ 매크로의 힘과 위험성

바벨이 async/await을 제너레이터로 변환하듯, 리스프에서는 사용자가 직접 매크로로 이를 처리할 수 있다. 그러나 이런 유연함은 명확한 철학과 팀 내 합의 없이 사용할 경우 유지보수에 큰 장애가 된다. 리스프가 강력하면서도 널리 쓰이지 않는 이유는 이처럼 사용의 복잡성과 위험성 때문이다.
