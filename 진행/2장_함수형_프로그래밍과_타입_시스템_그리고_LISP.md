# 2장. 함수형 프로그래밍과 타입 시스템 그리고 LISP

> 스터디 중 나누었던 이야기들을 주제별로 요약하였습니다.

## 📌 1. 타입 시스템의 보수적 설계

타입스크립트는 고차 함수가 다루는 일급 함수의 인자나 반환값은 넓은 타입으로 추론한다.

함수가 반환만 되고 인자 타입이 명확히 지정되지 않았다면, 타입스크립트는 타입을 넓히는 경향이 있다.

타입 시스템을 보수적으로 설계를 해놔서 그런 것으로 추측함

## 📌 2. 함수 제네릭과 타입 범위

함수형 프로그래밍에서는 제네릭을 사용한 타입 추론 범위 제한이 중요하다.

좁은 타입(예: "a")은 넓은 타입(string)에 할당 가능하지만, 반대는 불가능하다.

반환 타입의 안정성을 위해 제네릭의 사용 위치나 범위를 전략적으로 조절해야 한다.

## 📌 3. 리듀스에서의 에러 처리 전략

reduce는 인자 누락, undefined 허용 여부 등에서 에러 처리의 기준이 애매해질 수 있다.

예외 처리 방법으로는:

- 함수 내부에서 체크
- 호출 전 데이터 정제
- 옵셔널 체이닝
- 타입으로 제한

의도적으로 undefined를 허용할지 여부를 함수 시그니처에서 드러내는 것이 중요하다.

## 📌 4. forEach의 지연 평가

map, filter는 평가를 미루고, take, find 같은 메서드에서 평가가 시작된다.

forEach는 void 반환으로 콜백 함수를 즉시 실행하며 지연 평가가 불가능하다. 왜 forEach는 제너레이터를 사용하여 구현하지 않았을까?

- map이나 filter는 이터러블을 반환하므로 이터러블에 대해 닫혀 있는 연산이라 할 수 있다. 따라서 map이나 filter는 제너레이터로 구현될 수밖에 없음.
- forEach는 그렇지 않다. forEach는 이터러블을 반환하는 것이 아닌, 사이드 이펙트를 발생시키는 작업이다. 따라서 제너레이터 구현이 필요하지 않을 것으로 예상된다.

## 📌 6. 메타 프로그래밍 개념

메타 프로그래밍은 "코드가 코드를 다룬다"는 개념이다.

바벨 트랜스파일링, 타입스크립트 컴파일 등이 대표적인 예시다.

리스프(LISP)는 메타 프로그래밍의 대표 언어로, S-expression을 통해 코드와 데이터를 동일하게 다룬다.

## 📌 7. LISP

LISP는 데이터와 함수 모두 리스트라는 형식으로 표현한다. 데이터와 함수 모두 코드로 바라볼 수 있다.

- S-expression : 리스트 형태의 구문 표현이다. 이를 통해 코드와 데이터를 동일한 구조(리스트)로 다룰 수 있다.
- 매크로 : 매크로는 리스트 형태의 코드를 입력받아서 리스트 형태의 코드를 반환하는 하나의 함수이다. 컴파일 타임에 작동하여, 아직 코드가 실행되지 않았을 때 원하는 형태로 재구성한다.

```clojure
; 여기서 |>는 매크로를 사용하여 만든 pipe operator이다.
naturals(3)
  |> filter(n => n % 2 === 1, %) ; %는 변수 인자(이터러블 인자가 들어감)
  |> map(n => n * 10, %)
  |> forEach(printNumber, %)
```

> LISP는 매크로를 사용하여 파이프 오퍼레이터를 만들어 리스트 프로세싱 코드를 만들 수 있다. 그렇다면 타입스크립트는 어떻게 리스트 프로세싱 코드를 만들 수 있을까?

## 📌 7. TypeScript에서의 멀티 패러다임

리스프는 코드 자체를 데이터처럼 다루지만, TypeScript는 그 수준까지는 지원하지 않는다.

타입 정의나 클래스 구조 등은 리스프의 형태를 부분적으로만 흉내낼 수 있으므로 완전한 코드-데이터 동일성을 원한다면, TypeScript는 한계가 명확하다.

리스트 프로세싱 코드를 LISP에서 구현하기 위해서는 S-expression과 매크로가 사용되었지만, 타입스크립트에서 이를 구현하기 위해서는 여러 프로그래밍 패러다임을 같이 사용하여야 한다.

FxIterable을 구현하기 위해

- 객체지향 : class, 이터레이션 프로토콜
- 함수형 : 고차 함수
- 명령형 : 제너레이터

총 3개의 패러다임을 사용하여 리스트 프로세싱을 구현할 수 있다.

```typescript
class FxIterable<A> {
  constructor(private iterable: Iterable<A>) {}

  map<B>(f: (a: A) => B): FxIterable<B> {
    return fx(map(f, this.iterable));
  }

  filter(f: (a: A) => boolean): FxIterable<A> {
    return fx(filter(f, this.iterable));
  }

  forEach(f: (a: A) => void): void {
    return forEach(f, this.iterable);
  }
}

function fx<A>(iterable: Iterable<A>): FxIterable<A> {
  return new FxIterable(iterable);
}

const mapped = fx(["a", "b"]) // [const mapped: FxIterable<string>]
  .map((a) => a.toUpperCase()) // [a: string]
  .map((a) => a + a) // [a: string]
  .forEach((a) => console.log(a));
```

## 📌 8. 자바스크립트의 함수형 프로그래밍

자바스크립트는 클로저나 리스프에서 영향을 받은 부분이 많으며, 함수형 프로그래밍 패턴이 점점 보편화되고 있다.

특정 패러다임이 우위에 있다고 보지 않고, 필요에 따라 조합해서 쓰는 것이 가장 실용적이다.
